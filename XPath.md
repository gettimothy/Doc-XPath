# Table of Contents1.  [XPath [XPathHelp]](#orgd766263)    1.  [Todo](#org31ba66c)    2.  [Introduction](#org1321fce)    3.  [Installation](#org788d4b0)    4.  [XMLDocument Retrieval](#org28c410e)    5.  [Interoperability Fix](#orgcc4049d)    6.  [Adding Complexity](#org7090e5e)    7.  [Preliminaries on XMLDocument](#org054d945)    8.  [XMLDocument Structure](#org0b2c96c)    9.  [Location Step](#org244eca4)    10. [Location Step Axis](#org34a7929)    11. [Location Step Node Test](#orgc80ee48)    12. [Location Step Predicate](#org50592fd)    13. [Location Path Defined](#org1a422e1)    14. [Axis Ancestor Examples](#org0b2250e)    15. [Axis Ancestor Or Self Examples](#org66be1bf)    16. [Axis Attribute Examples](#orgc1bcc27)    17. [Axis Child Examples](#org06f12e0)    18. [Axis Descendant Examples](#org379da96)    19. [Axis Descendent or Self Examples](#orga79c365)    20. [Axis Following Examples](#orgb0169c1)    21. [Axis Following Sibling Examples](#org6a5f12c)    22. [Axis Namespace Examples](#orga6a0f1e)    23. [Axis Parent Examples](#org1ec30ef)    24. [Axis Preceding Examples](#org04743d4)    25. [Axis Preceding Sibling  Examples](#org1f0671b)    26. [Axis Self Examples](#org8ef9e53)    27. [Location Path Examples](#orgee8aaf3)    28. [Wildcards in Queries](#org6cdabbc)    29. [Selecting Union Operator](#org159eddc)    30. [Operator Precedence](#org293892b)    31. [NodeSet Functions](#orgecf8a0f)    32. [String Functions](#org5853d8f)    33. [Boolean Functions](#orgef96934)    34. [Number Functions](#org27b363c)    35. [Definitions  [XPathDefinitionsHelp]](#orgda584ff)        1.  [Context Node](#org04a9f6f)        2.  [Context Node Set](#orgaceea31)        3.  [Current Node](#org915faef)        4.  [Document Element](#orgccdf420)        5.  [Filter](#org4e5908f)        6.  [Location Path Expression](#orge8915d6)        7.  [Location Step](#orgc091451)        8.  [Node Test](#org8468530)        9.  [Root Node](#org9cfa680)        10. [Nodes](#org1c66270)        11. [NodeSets](#org67eed79)        12. [Atomic Values [atomics]](#org547b3f6)        13. [Basic Tree Relationships [relatives]](#org3464df8)        14. [Expr](#org930133e)        15. [NCName](#org37e40ee)        16. [QName](#org924c9ff)        17. [Predicate](#org805bc5a)    36. [Bibliography](#orgad92c00)<a id="orgd766263"></a># XPath [XPathHelp]<a id="org31ba66c"></a>## Todo    bring every function into every axis examples set.    provide a "howto"  section    example?     How do I select an element's contents?    How do I exclude empty text nodes from a nodeset?       axis::node()[not(self::text())]    that sort of stuff.  (check out stack exchange for example questions)    provide shorter XMLDocument examples for the current longer axis <a id="org1321fce"></a>## Introduction        This book provides examples on coding XPath on a live XMLDocument from the web.        It uses Monty's XML Suite available from the squeak metacello repository.                     https://www.w3.org/TR/1999/REC-xpath-19991116/#section-Introduction            1. XPath is a notation for retrieving information from a document.    2. The information could be a set of nodes or derived values.    3. XPath allows you to identify parts of an XML document.    4. XPath allows you to test whether or not a node matches a particular pattern.    5. XPath provides       1. Boolean logic       2. filters       3. indexing into collections of nodes       4. ??    6. XPath is declarative not procedural.    7. XPath provides a common syntax for features shared by Extensible Stylesheet Language Transformations (XSLT) and XQuery.       1. XSLT is a language for transforming XML documents into XML, HTML, or text.       2. XQuery builds on XPath and is a language for extracting information from XML documents.    8. The basic syntax for XPath mimics the Uniform Resource Identifier (URI) directory navigation syntax. <a id="org788d4b0"></a>## Installation        (note, after installing below, I had to go into Monticello and upgrade the packages to eradicate some existing bugs.     I did not try a different MetaCello load because I am lazy)        Installer ss           project: 'MetacelloRepository';           install: 'ConfigurationOfXMLParser'.        (Smalltalk at:#ConfigurationOfXMLParser) loadDefault .        Installer ss           project: 'MetacelloRepository';    	install:'ConfigurationOfXMLSupport'.    (Smalltalk at:#ConfigurationOfXMLSupport) loadDefault .	         Installer ss           project: 'MetacelloRepository';	    	install: 'ConfigurationOfXMLWriter'.    (Smalltalk at:#ConfigurationOfXMLWriter) load .		            Installer ss           project: 'MetacelloRepository';    	install: 'ConfigurationOfXMLParserHTML'.    (Smalltalk at:#ConfigurationOfXMLParserHTML) load .	            Installer ss           project: 'MetacelloRepository';	    	install: 'ConfigurationOfXMLParserStAX'.    (Smalltalk at:#ConfigurationOfXMLParserStAX) load .		        Installer ss           project: 'MetacelloRepository';    	install: 'ConfigurationOfXMLRPC'.      (Smalltalk at:#ConfigurationOfXMLRPC) load .	            Installer ss           project: 'MetacelloRepository';    	install: 'ConfigurationOfXPath'.    (Smalltalk at:#ConfigurationOfXPath) load .	<a id="org28c410e"></a>## XMLDocument Retrieval    Many of the  examples in this document use the following to retrieve the XML and Parse it.        (XMLDOMParser onURL: 'https://w1.weather.gov/xml/current_obs/index.xml' upToLimit:nil) parseDocument; explore.         This Document is then modified to add complexity as shown in the 'Adding Complexity" section below.        For non-intuitive axis like preceding or following we use the simpler document shown here:        |tree doc|    tree := '<?xml version="1.0" encoding="UTF-8"?>        <bookstore>        <book category="COOKING">      <title lang="en">Everyday Italian</title>      <author>Giada De Laurentiis</author>      <year>2005</year>      <price>30.00</price>    </book>        <book category="CHILDREN">      <title lang="en">Harry Potter</title>      <author>J K. Rowling</author>      <year>2005</year>      <price>29.99</price>    </book>        <book category="WEB">      <title lang="en">XQuery Kick Start</title>      <author>James McGovern</author>      <author>Per Bothner</author>      <author>Kurt Cagle</author>      <author>James Linn</author>      <author>Vaidyanathan Nagarajan</author>      <year>2003</year>      <price>49.99</price>    </book>        <book category="WEB">      <title lang="en">Learning XML</title>      <author>Erik T. Ray</author>      <year>2003</year>      <price>39.95</price>    </book>        </bookstore>'.        doc := (XMLDOMParser on: tree) parseDocument.    doc explore.<a id="orgcc4049d"></a>## Interoperability Fix        Many of the  examples in this document use the following to retrieve the XML and Parse it.            (XMLDOMParser onURL: 'https://w1.weather.gov/xml/current_obs/index.xml' upToLimit:nil) parseDocument; explore.             If that does not work for you then the below should:                |tree url |        url := 'https://w1.weather.gov/xml/current_obs/index.xml'.        tree := (XMLDOMParser on:  (HTTPLoader default retrieveContentsFor: url) contents        ) parseDocument.        tree explore.               For the adventurous, a fix is to edit. and add the two top lines. (the second is commented out, but may come in handy some day)            XMLHTTPWebClientRequest>>basicSend            	self webClientClient userAgent ifNotNil:[:ua | webClientRequest headerAt: 'User-Agent' put: ua].    "	self webClientClient contentDecoders ifNotNil: [:decoders | webClientRequest headerAt: 'Accept-Encoding' put: decoders]."            	^ self responseClass    		request: self    		webClientResponse:    			(self webClientClient    				"#sendRequest: unfortunately requires #initializeFromUrl:    				to be sent first"    				initializeFromUrl: self url;    				sendRequest: self webClientRequest)               That was a patch I made and I am awaiting approval from the package maintainers.<a id="org7090e5e"></a>## Adding ComplexityTo make the examples more interesting, we are going to add stations with substations to theXMLDocument  that exist in their own namespace.    |tree node   |        tree :='<s:wx_station_index subs="yes" xmlns:s="https://dummynamespace.org/s/">      <!--comment at s:wx_station_index level-->      <s:station subs="yes">       <?s:station-processing-instruction   type = "ABC"?>       <!--comment station ABC-->       <![CDATA[          station ABC CDATA       ]]>       <s:station_id>ABC</s:station_id>       <s:state>NZ</s:state>       <s:station_name>ABC_ONE</s:station_name>       <s:latitude>51.76667</s:latitude>       <s:longitude>-114.68333</s:longitude>       <s:html_url>http://w1.weather.gov/data/obhistory/CWAV.html</s:html_url>       <s:rss_url>http://weather.gov/xml/current_obs/CWAV.rss</s:rss_url>       <s:xml_url>http://weather.gov/xml/current_obs/CWAV.xml</s:xml_url>       <s:substations>        <s:substation location="north">          <!--comment station ABC1-->          <s:sub_station_id>ABC1</s:sub_station_id>          <s:sub_station_name>ABC_SUB_ONE</s:sub_station_name>        </s:substation>    <s:substation location="northeast">          <s:sub_station_id>ABC2</s:sub_station_id>          <s:sub_station_name>ABC_SUB_TWO</s:sub_station_name>          <!--comment station ABC2-->        </s:substation>        <s:substation location="east">           <s:sub_station_id>ABC3</s:sub_station_id>          <s:sub_station_name>ABC_SUB_THREE</s:sub_station_name>          <!--comment station ABC3-->        </s:substation>        <s:substation location="south">          <s:sub_station_id>ABC4</s:sub_station_id>          <s:sub_station_name>ABC_SUB_FOUR</s:sub_station_name>          <!--comment station ABC4-->        </s:substation>        <s:substation  location="west">          <s:sub_station_id>ABC5</s:sub_station_id>          <s:sub_station_name>ABC_SUB_FIVE</s:sub_station_name>          <!--comment station ABC5-->        </s:substation>       </s:substations>      </s:station>      <s:station subs="yes">       <?s:station-processing-instruction   type = "MNO"?>       <!--comment station MNO-->       <![CDATA[          station MNO CDATA       ]]>       <s:station_id>MNO</s:station_id>       <s:state>NZ</s:state>       <s:station_name>MNO_ONE</s:station_name>       <s:latitude>51.76667</s:latitude>       <s:longitude>-114.68333</s:longitude>       <s:html_url>http://w1.weather.gov/data/obhistory/CWAV.html</s:html_url>       <s:rss_url>http://weather.gov/xml/current_obs/CWAV.rss</s:rss_url>       <s:xml_url>http://weather.gov/xml/current_obs/CWAV.xml</s:xml_url>       <s:substations>        <s:substation location="north">          <!--comment station MNO1-->          <s:sub_station_id>MNO1</s:sub_station_id>          <s:sub_station_name>MNO_SUB_ONE</s:sub_station_name>        </s:substation>        <s:substation location="northeast">          <s:sub_station_id>MNO2</s:sub_station_id>          <s:sub_station_name>MNO_SUB_TWO</s:sub_station_name>          <!--comment station MNO2-->        </s:substation>        <s:substation location="east">           <s:sub_station_id>MNO3</s:sub_station_id>          <s:sub_station_name>MNO_SUB_THREE</s:sub_station_name>          <!--comment station MNO3-->        </s:substation>        <s:substation location="south">          <s:sub_station_id>MNO4</s:sub_station_id>          <s:sub_station_name>MNO_SUB_FOUR</s:sub_station_name>          <!--comment station MNO4-->        </s:substation>        <s:substation  location="west">          <s:sub_station_id>MNO5</s:sub_station_id>          <s:sub_station_name>MNO_SUB_FIVE</s:sub_station_name>          <!--comment station MNO5-->        </s:substation>       </s:substations>      </s:station>      <s:station subs="yes">       <?s:station-processing-instruction   type = "XYZ"?>       <!--comment station XYZ-->       <![CDATA[          station XYZ CDATA       ]]>       <s:station_id>XYZ</s:station_id>       <s:state>NZ</s:state>       <s:station_name>XYZ_ONE</s:station_name>       <s:latitude>51.76667</s:latitude>       <s:longitude>-114.68333</s:longitude>       <s:html_url>http://w1.weather.gov/data/obhistory/CWAV.html</s:html_url>       <s:rss_url>http://weather.gov/xml/current_obs/CWAV.rss</s:rss_url>       <s:xml_url>http://weather.gov/xml/current_obs/CWAV.xml</s:xml_url>       <s:substations>        <s:substation location="north">          <!--comment station XYZ1-->          <s:sub_station_id>XYZ1</s:sub_station_id>          <s:sub_station_name>XYZ_SUB_ONE</s:sub_station_name>        </s:substation>        <s:substation location="northeast">          <s:sub_station_id>XYZ2</s:sub_station_id>          <s:sub_station_name>XYZ_SUB_TWO</s:sub_station_name>          <!--comment station XYZ2-->        </s:substation>        <s:substation location="east">           <s:sub_station_id>XYZ3</s:sub_station_id>          <s:sub_station_name>XYZ_SUB_THREE</s:sub_station_name>          <!--comment station XYZ3-->        </s:substation>        <s:substation location="south">          <s:sub_station_id>XYZ4</s:sub_station_id>          <s:sub_station_name>XYZ_SUB_FOUR</s:sub_station_name>          <!--comment station XYZ4-->        </s:substation>        <s:substation  location="west">          <s:sub_station_id>XYZ5</s:sub_station_id>          <s:sub_station_name>XYZ_SUB_FIVE</s:sub_station_name>          <!--comment station XYZ5-->        </s:substation>       </s:substations>      </s:station>     </s:wx_station_index>' .        node := (XMLDOMParser parse: tree).         self firstNode addNode:(node firstNode).            "self firstNode lastNode expandedName."<a id="org054d945"></a>## Preliminaries on XMLDocumentIn this section, we get  familiar with the structure of a  XMLDocument object through a portion of it's api.The protocol for XMLDocument is huge. Do not worry about using it. We will be using XPath to operate on the Document.However, some basic orientation is appropriate as some method names differ from terminology used by some websites.         (XMLDOMParser parseURL: 'https://w1.weather.gov/xml/current_obs/index.xml')  explore.                (self document) .       "this is like reading the xml file. it contains the <?xml ...?> thing"    (self xpath:'/') .      "returns an XPathNodeSet containing the file"    (self document) = ((self xpath:'/')  first).    " true "                (self root).                   "the outermost XMLElement in the document excluding the <?xml..?> stuff"    (self root)  = (self document).  "false "      "The root and the Document are not the same thing"    self root class                "XMLElement "    self root name                  'wx_station_index'                             "the root element is the same as the first element in the xpath NodeSet     in these two ways of expressing the outermost XMLElement in the XMLDocument"    (self root)  = ((self xpath:'/wx_station_index') first)    (self root)  = ((self xpath:'/node()') first).        "throws an error because all xpath queries are relative to a Context Node and we have not specified a ContextNode (terms to be explained later. do not sweat it now "    self xpath:''.            self class                     "XMLDocument "    self version                   "1.0"     self encoding                  'UTF-8'     self document version.         "1.0"     self document encoding.        "'UTF-8' "<a id="org0b2c96c"></a>## XMLDocument Structure        This content sumamrized from here: https://www.stylusstudio.com/docs/v2009R2/d_xpath15.html#wp231687        Xpath operatates on a tree representation of XML data.            1. Root Node           1. Comment           2. Processing Instruction           3. Document Element  <-- we are here?    	  1. Element*    	  2. Comment*    	  3. Processing Instruction*    	  4. Text*        The root node has no text associated with it. You can think of the filename as the root node.        A Document element is required and there can be only one. (an Element is a Node, btw)    The Document Element contains zero or more of its sub-elements.<a id="org244eca4"></a>## Location Step        A location step has the form: axis::node-test[predicate]*            We will fill in the details from left to right  below.<a id="org34a7929"></a>## Location Step Axis        We are on the "axis" part of  axis::node-test[predicate]*        An axis specifies a list of nodes in relation to a context node.         If you picture yourself as a node somewhere in the XMLDocument then    1. you are the context node    2. Axis tell you where  to look for other nodes.        to visualize axis, see the diagram below.        https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041            If I am a context node somewhere in the midst of the tree...    1. Ancestors are the direct line from me to the top of the tree.    2. Parent is the Ancestor immediately above me.    3. Descendants are the connected nodes below me.    4. Children are Descendants one step below me.    5. Siblings are nodes at the same depth in the tree as me.    6. Preceding are Siblings  to my left (looking towards the tree)    7. Following are Siblings to my right (looking towards the tree)    8. Self is me.                An axis is either a forward axis or a reverse axis.     An axis that only ever contains the context node or nodes that are after the context node in document order is a forward axis.     An axis that only ever contains the context node or nodes that are before the context node in document order is a reverse axis.     Thus, the ancestor, ancestor-or-self, preceding, and preceding-sibling axes are reverse axes;     all other axes are forward axes.     Since the self axis always contains at most one node, it makes no difference whether it is a forward or reverse axis.     The proximity position of a member of a node-set with respect to an axis is defined to be     the position of the node in the node-set ordered in document order if the axis is a forward axis and     ordered in reverse document order if the axis is a reverse axis.     The first position is 1.                     ancestor     ancestor-or-self     attribute     child     descendant     descendant-or-self     following     following-sibling     namespace     parent     preceding     preceding-sibling     self         We will be  using these axis later.         Our Location Step form now looks like this:         ancestor::node-test[predicate]*     ancestor-or-self::node-test[predicate]*     attribute::node-test[predicate]*     child::node-test[predicate]*     descendant::node-test[predicate]*     descendant-or-self::node-test[predicate]*     following::node-test[predicate]*     following-sibling::node-test[predicate]*     namespace::node-test[predicate]*     parent::node-test[predicate]*     preceding::node-test[predicate]*     preceding-sibling::node-test[predicate]*     self::node-test[predicate]*<a id="orgc80ee48"></a>## Location Step Node Test    We are on the "node-text" part of  axis::node-test[predicate]*        The node tests are:        1. QName  (basically 'Foo" or 'Foo:Bar'. see Definitions for more)    2. *    3. comment()     4. node()    5. processing-instruction()    6. text()         Every axis has a principle node type which drives the type of node test we use           1. For the attribute axis the principle node type is attribute        2. For the namespace axis the principle node type is namespace       3. For the other axis the principle node type is element.            1. axis::QName       1. selects any elments or attributes whose QName is QName          1. attribute::href    	 1. selects the href attribute          2. child::foo    	 1. selects the child elements named foo    2. axis::*       1. selects any node of the principle node type.          1. child::*    	 1. will select all element children of the context node          2. attribute::*    	 1. will select all attributes of the context node.    3. axis::comment()       1. selects comment nodes    4. axis::node()       1. selects any type of node    5. axis::processing-instruction()       1. selects a processing instruction node          1. a processing node looks like this: <?PITarget PIContent?>       2. You can specify the name of the processing instruction to select in the parentheses.  (what is name? PITarget?)    6. axis::text()       1. selects a text node.<a id="org50592fd"></a>## Location Step Predicate         We are on the "[predicate]*" part of  axis::node-test[predicate]*        A predicate filters a node-set with respect to an axis to produce a new node-set.         For each node in the node-set to be filtered, the PredicateExpr is evaluated with that node as the context node,     with the number of nodes in the node-set as the context size,     and with the proximity position of the node in the node-set with respect to the axis as the context position;     if PredicateExpr evaluates to true for that node, the node is included in the new node-set; otherwise, it is not included.        Recall that     An axis is either a forward axis or a reverse axis.     An axis that only ever contains the context node or nodes that are after the context node in document order is a forward axis.     An axis that only ever contains the context node or nodes that are before the context node in document order is a reverse axis.     Thus, the ancestor, ancestor-or-self, preceding, and preceding-sibling axes are reverse axes;     all other axes are forward axes.     Since the self axis always contains at most one node, it makes no difference whether it is a forward or reverse axis.         The proximity position of a member of a node-set with respect to an axis is defined to be     the position of the node in the node-set ordered in document order if the axis is a forward axis and     ordered in reverse document order if the axis is a reverse axis.     The first position is 1.            Here are some examples of the above (TODO turn these into real examples. I will need to modify the XMLDocument for stuff like this.)           /child::doc/child::chapter[position()=5]/child::section[position()=2]           child::para[attribute::type="warning"]           child::para[attribute::type='warning'][position()=5]           child::para[position()=5][attribute::type="warning"]           child::chapter[child::title='Introduction']           child::chapter[child::title]           child::*[self::chapter or self::appendix]           child::*[self::chapter or self::appendix][position()=last()]           child::para[position()=1]           child::para[position()=last()]           child::para[position()=last()-1]           child::para[position()>1]       /descendant::figure[position()=42]       following-sibling::chapter[position()=1]       preceding-sibling::chapter[position()=1]<a id="org1a422e1"></a>## Location Path Defined        A Location Path  is a series of Location Steps (? true ?)        A Location Path (or even parts of it) can be an Absolute XPath  or Relative XPath           https://stackoverflow.com/questions/27183353/what-is-the-difference-between-absolute-and-relative-xpaths-which-is-preferred              1. Absolute XPath         1. Uses a complete path from the root element to the desired element    	1. xpath:'/foo/bar/baz/biz/quiz/tiz/xiz'.    	2. xpath:'/foo/bar/baz/biz/quiz/tiz/xiz/ziz'.    	3. xpath:'/axis::node-test[predicate]*/axis::node-test[predicate]*/axis::node-test[predicate]*'      2. Relative XPath         1. You start by referencing the element you want and go from there.         2. xpath:'//ziz'.         3. xpath:'//xiz[@name="email"]'         4. xpath:'//axis::node-test[predicate]*'      3. Mixed XPath         1. xpath:'/axis::node-test[predicate]*//biz'<a id="org0b2250e"></a>## Axis Ancestor Examples    ancestor::node-test[predicate]*        To visualize, see https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041        contains ancestors of the context node.    1. Parent    2. Parent of parent    3. Etc...    5. Always includes the root node unless the context node is the root node        First, we use a simple XMLDocument to explore.        |tree doc|    tree := '<?xml version="1.0" encoding="UTF-8"?>        <bookstore>        <book category="COOKING">      <title lang="en">Everyday Italian</title>      <author>Giada De Laurentiis</author>      <year>2005</year>      <price>30.00</price>    </book>        <book category="CHILDREN">      <title lang="en">Harry Potter</title>      <author>J K. Rowling</author>      <year>2005</year>      <price>29.99</price>    </book>        <book category="WEB">      <title lang="en">XQuery Kick Start</title>      <author>James McGovern</author>      <author>Per Bothner</author>      <author>Kurt Cagle</author>      <author>James Linn</author>      <author>Vaidyanathan Nagarajan</author>      <year>2003</year>      <price>49.99</price>    </book>        <book category="WEB">      <title lang="en">Learning XML</title>      <author>Erik T. Ray</author>      <year>2003</year>      <price>39.95</price>    </book>        </bookstore>'.        doc := (XMLDOMParser on: tree) parseDocument.    doc explore.            self xpath:'ancestor::node()'.    self xpath:'/ancestor::node()'.    self xpath:'/ancestor::*'.       self xpath:'/child::node()/book/ancestor::node()[not(self::text())]'.   "reverse document order"    self xpath:'//author[text() = "James McGovern"]'.    self xpath:'//author[text() = "James McGovern"]/ancestor::node()'.    self xpath:'//author[text() = "James Linn"]/ancestor::node()'.        "Below here, we operate on a larger document"        (((XMLDOMParser onURL: 'https://w1.weather.gov/xml/current_obs/index.xml' upToLimit:nil)    	preservesCDataNodes: true;     	preservesCommentNodes: true) parseDocument) explore        "be sure to add the additional elements from the "Addding Complexity" section        self xpath:'/ancestor::node()'.    self xpath:'/child::node()/ancestor::node()'.    (self xpath:'/child::node()/ancestor::node()') = (self xpath:'/self::node()').        it is best to inspect (rather then print)  the below results to get a sense of what this axis returns.            "me myself and root"        self xpath:'/ancestor::node()'.    self xpath:'/child::node()/ancestor::node()'.        (self xpath:'/child::node()/ancestor::node()') = (self xpath:'/self::node()').            "ws_station_index"            self xpath:'/child::node()/child::credit/ancestor::node()'.        self xpath:'/child::node()/child::station/ancestor::node()'.        self xpath:'/child::node()/child::station[position()=1]/ancestor::node()'.        self xpath:'/child::node()/child::station[last()]/ancestor::node()'.        self xpath:'/child::node()/child::station[last()]/ancestor::node()[position()=1]'.    "s:ws_station_index"        self xpath:'/child::node()/child::s:wx_station_index/ancestor::node()'.        self xpath:'/child::node()/child::s:wx_station_index/ancestor::node()[position()=1]'.    "s:station"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station/ancestor::node()'.        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[last()]/ancestor::node()'.        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[last()]/ancestor::node()[position()=1]'.        "reverse document order"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[last()]/ancestor::node()[position()=2]'.        "reverse document order"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[last()]/ancestor::node()[position()=3]'.        "reverse document order"    "s:wx_station_index/s:station/"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/ancestor::node()'.         self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/ancestor::node()[position()=1]'.   "reverse document order"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/ancestor::node()[position()=2]'.   "reverse document order"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/ancestor::node()[position()=3]'.   "reverse document order"    "s:wx_station_index/s:station/s:substations/"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations[position()=1]/child::node()[position()=1]/ancestor::node()'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations[position()=1]/child::node()[position()=1]/ancestor::node()[position()=1]'.        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations//text()'.    "note this only selects contents of following nodes"        "s:wx_station_index/s:station/s:substations/s:substation"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations[position()=1]/child::s:substation[position()=1]/ancestor::node()'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations[position()=1]/child::s:substation[position()=1]/ancestor::node()[self::node()]'.  <a id="org66be1bf"></a>## Axis Ancestor Or Self Examples    ancestor-or-self::node-test[predicate]*        To visualize, see https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041            ancestor-or-self axis contains     1. The context node    2. Parent    3. Parent of parent    4. Etc..    5. Always includes the root node unless the context node is the root node        First, we use a simple XMLDocument to explore.        |tree doc|    tree := '<?xml version="1.0" encoding="UTF-8"?>        <bookstore>        <book category="COOKING">      <title lang="en">Everyday Italian</title>      <author>Giada De Laurentiis</author>      <year>2005</year>      <price>30.00</price>    </book>        <book category="CHILDREN">      <title lang="en">Harry Potter</title>      <author>J K. Rowling</author>      <year>2005</year>      <price>29.99</price>    </book>        <book category="WEB">      <title lang="en">XQuery Kick Start</title>      <author>James McGovern</author>      <author>Per Bothner</author>      <author>Kurt Cagle</author>      <author>James Linn</author>      <author>Vaidyanathan Nagarajan</author>      <year>2003</year>      <price>49.99</price>    </book>        <book category="WEB">      <title lang="en">Learning XML</title>      <author>Erik T. Ray</author>      <year>2003</year>      <price>39.95</price>    </book>        </bookstore>'.        doc := (XMLDOMParser on: tree) parseDocument.    doc explore.        self xpath:'ancestor-or-self::node()'.    self xpath:'/ancestor-or-self::node()'.    self xpath:'/ancestor-or-self::*'.       self xpath:'/child::node()/book/ancestor-or-self::node()[not(self::text())]'.   "reverse document order"    self xpath:'//author[text() = "James McGovern"]'.    self xpath:'//author[text() = "James McGovern"]/ancestor-or-self::node()'.    self xpath:'//author[text() = "James Linn"]/ancestor-or-self::node()'.                "Below here, we operate on a larger document"            (((XMLDOMParser onURL: 'https://w1.weather.gov/xml/current_obs/index.xml' upToLimit:nil)    	preservesCDataNodes: true;     	preservesCommentNodes: true) parseDocument) explore        "be sure to add the additional elements from the "Addding Complexity" section           self xpath:'/ancestor-or-self::node()'.       self xpath:'/child::node()/ancestor-or-self::node()'.       self xpath:'/child::node()/child::node()/ancestor-or-self::node()'.       self xpath:'/child::node()/child::node()/ancestor-or-self::node()[not(self::text())]'.  "excludes text nodes"            "ws_station_index"            self xpath:'/child::node()/child::credit/ancestor-or-self::node()'.        self xpath:'/child::node()/child::station/ancestor-or-self::node()'.        self xpath:'/child::node()/child::station[position()=1]/ancestor-or-self::node()'.        self xpath:'/child::node()/child::station[last()]/ancestor-or-self::node()'.        self xpath:'/child::node()/child::station[last()]/ancestor-or-self::node()[position()=1]'.    "s:ws_station_index"        self xpath:'/child::node()/child::s:wx_station_index/ancestor-or-self::node()'.        self xpath:'/child::node()/child::s:wx_station_index/ancestor-or-self::node()[position()=1]'.    "s:station"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station/ancestor-or-self::node()'.        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[last()]/ancestor-or-self::node()'.        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[last()]/ancestor-or-self::node()[position()=1]'.        "reverse document order"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[last()]/ancestor-or-self::node()[position()=2]'.        "reverse document order"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[last()]/ancestor-or-self::node()[position()=3]'.        "reverse document order"    "s:wx_station_index/s:station/"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/ancestor-or-self::node()'.         self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/ancestor-or-self::node()[position()=1]'.   "reverse document order"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/ancestor-or-self::node()[position()=2]'.   "reverse document order"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/ancestor-or-self::node()[position()=3]'.   "reverse document order"    "s:wx_station_index/s:station/s:substations/"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations[position()=1]/child::node()[position()=1]/ancestor-or-self::node()'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations[position()=1]/child::node()[position()=1]/ancestor-or-self::node()[position()=1]'.        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations//text()'.    "note this only selects contents of following nodes"        "s:wx_station_index/s:station/s:substations/s:substation"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations[position()=1]/child::s:substation[position()=1]/ancestor-or-self::node()'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations[position()=1]/child::s:substation[position()=1]/ancestor-or-self::node()[self::node()]'.  <a id="orgc1bcc27"></a>## Axis Attribute Examples        attribute::node-test[predicate]*        '@' is shortant for 'attribute::'        The attribute axis contains    1. The attributes of the context node    2. Is empty when the context node is  an element            (((XMLDOMParser onURL: 'https://w1.weather.gov/xml/current_obs/index.xml' upToLimit:nil)    	preservesCDataNodes: true;     	preservesCommentNodes: true) parseDocument) explore        "be sure to add the additional elements from the "Addding Complexity" section            self xpath:'//attribute::*'.    self xpath:'//attribute::location'.    self xpath:'//node()[attribute::location="east"]'.    self xpath:'//node()[attribute::subs="yes"]'.        '@' is shortant for 'attribute::'        self xpath:'//@*'.    self xpath:'//@location'.    self xpath:'//node()[@location="east"]'.    self xpath:'//node()[@subs="yes"]'.<a id="org06f12e0"></a>## Axis Child Examples        child::node-test[predicate]*                To visualize, see https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041            The child axis contains         1. The children of the context node.         2. Children are immediate descendants                     (((XMLDOMParser onURL: 'https://w1.weather.gov/xml/current_obs/index.xml' upToLimit:nil)    	    preservesCDataNodes: true;     	    preservesCommentNodes: true) parseDocument) explore            "be sure to add the additional elements from the "Addding Complexity" section                "ws_station_index"            self xpath:'/child::node()/child::credit'.        self xpath:'/child::node()/child::station'.        self xpath:'/child::node()/child::station[position()=1]'.        self xpath:'/child::node()/child::station[last()]'.    "s:ws_station_index"        self xpath:'/child::node()/child::s:wx_station_index'.    "s:station"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station'.        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[@*]'.        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]'.        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1][@*]'.        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[last()]'.    "s:wx_station_index/s:station/"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::processing-instruction()'.         self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::comment()'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::text()'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::node()'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:station_id'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:station_state'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:station_name'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/self::node()'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations'.          "s:wx_station_index/s:station/s:substations/"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::node()'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::node()[@location="north"]'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::node()[@location="east"]'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::node()[@location="south"]'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::node()[@location="west"]'.      "s:wx_station_index/s:station/s:substations/s:substation"        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::s:substation'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::s:substation[@*]'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::s:substation[@location="north"]'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::s:substation[@location="east"]'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::s:substation[@location="south"]'.        self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::s:substation[@location="west"]'.            self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::s:substation[last()]/@*'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::s:substation[@location="north"]/s:sub_station_id'.          self xpath:'/child::node()/child::s:wx_station_index/child::s:station[position()=1]/child::s:substations/child::s:substation[@location="north"]/s:sub_station_name'.  <a id="org379da96"></a>## Axis Descendant Examples        descendant::node-test[predicate]*                To visualize, see https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041            A descendant axis contains the descendants of the context node.        1. A child        2. A child of a child        3. Never contains attribute nodes            First, we use a simple XMLDocument to explore.            |tree doc|        tree := '<?xml version="1.0" encoding="UTF-8"?>            <bookstore>            <book category="COOKING">          <title lang="en">Everyday Italian</title>          <author>Giada De Laurentiis</author>          <year>2005</year>          <price>30.00</price>        </book>            <book category="CHILDREN">          <title lang="en">Harry Potter</title>          <author>J K. Rowling</author>          <year>2005</year>          <price>29.99</price>        </book>            <book category="WEB">          <title lang="en">XQuery Kick Start</title>          <author>James McGovern</author>          <author>Per Bothner</author>          <author>Kurt Cagle</author>          <author>James Linn</author>          <author>Vaidyanathan Nagarajan</author>          <year>2003</year>          <price>49.99</price>        </book>            <book category="WEB">          <title lang="en">Learning XML</title>          <author>Erik T. Ray</author>          <year>2003</year>          <price>39.95</price>        </book>            </bookstore>'.            doc := (XMLDOMParser on: tree) parseDocument.        doc explore.            self xpath:'/descendant::node()'.        self xpath:'/descendant::*'.           self xpath:'/child::node()/book/descendant::node()[not(self::text())]'.          self xpath:'//author[text() = "James McGovern"]'.        self xpath:'//author[text() = "James McGovern"]/descendant::node()'.        self xpath:'//author[text() = "James Linn"]/descendant::node()'.                    "Below here, we operate on a larger document with an absolute path"                    (((XMLDOMParser onURL: 'https://w1.weather.gov/xml/current_obs/index.xml' upToLimit:nil)    	    preservesCDataNodes: true;     	    preservesCommentNodes: true) parseDocument) explore            "be sure to add the additional elements from the "Addding Complexity" section            it is best to inspect (rather then print)  the below results to get a sense of what this axis returns.               self xpath:'/descendant::*'.          self xpath:'/descendant::node()[not(self::text())]'.  "excludes text nodes".       "ws_station_index"            self xpath:'/descendant::node()/descendant::credit'.        self xpath:'/descendant::node()/descendant::station'.        self xpath:'/descendant::node()/descendant::station[position()=1]'.        (self xpath:'/descendant::node()/descendant::station[position()=1]') = (self xpath:'/descendant::node()/child::station[position()=1]').        self xpath:'/descendant::node()/descendant::station[last()]'.    "s:ws_station_index"        self xpath:'/descendant::node()/descendant::s:wx_station_index'.    "s:station"        self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station'.        self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[@*]'.        self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]'.        self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1][@*]'.        self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[last()]'.    "s:wx_station_index/s:station/"        self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::processing-instruction()'.         self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::comment()'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::text()'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::node()'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:station_id'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:station_state'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:station_name'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/self::node()'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations'.          "s:wx_station_index/s:station/s:substations/"        self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::node()'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::node()[@location="north"]'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::node()[@location="east"]'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::node()[@location="south"]'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::node()[@location="west"]'.      "s:wx_station_index/s:station/s:substations/s:substation"        self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::s:substation'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::s:substation[@*]'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::s:substation[@location="north"]'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::s:substation[@location="east"]'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::s:substation[@location="south"]'.        self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::s:substation[@location="west"]'.            self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::s:substation[last()]/@*'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::s:substation[@location="north"]/s:sub_station_id'.          self xpath:'/descendant::node()/descendant::s:wx_station_index/descendant::s:station[position()=1]/descendant::s:substations/descendant::s:substation[@location="north"]/s:sub_station_name'.  <a id="orga79c365"></a>## Axis Descendent or Self Examples        descendant-or-self::node-test[predicate]*        To visualize, see https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041        A descendant-or-self  axis contains     1. The context node    2. A child    3. A child of a child    4. Never contain attribute nodes (? correct ?)         '//' is shorthand for descendant-or-self::node()     '//name' is shorthand for descendant-or-self::node()/child::name.            First, we use a simple XMLDocument to explore.        |tree doc|    tree := '<?xml version="1.0" encoding="UTF-8"?>        <bookstore>        <book category="COOKING">      <title lang="en">Everyday Italian</title>      <author>Giada De Laurentiis</author>      <year>2005</year>      <price>30.00</price>    </book>        <book category="CHILDREN">      <title lang="en">Harry Potter</title>      <author>J K. Rowling</author>      <year>2005</year>      <price>29.99</price>    </book>        <book category="WEB">      <title lang="en">XQuery Kick Start</title>      <author>James McGovern</author>      <author>Per Bothner</author>      <author>Kurt Cagle</author>      <author>James Linn</author>      <author>Vaidyanathan Nagarajan</author>      <year>2003</year>      <price>49.99</price>    </book>        <book category="WEB">      <title lang="en">Learning XML</title>      <author>Erik T. Ray</author>      <year>2003</year>      <price>39.95</price>    </book>        </bookstore>'.        doc := (XMLDOMParser on: tree) parseDocument.    doc explore.        self xpath:'/descendant-or-self::node()'.    self xpath:'/descendant-or-self::*'.       self xpath:'/child::node()/book/descendant-or-self::node()[not(self::text())]'.      self xpath:'//author[text() = "James McGovern"]'.    self xpath:'//author[text() = "James McGovern"]/descendant-or-self::node()'.    self xpath:'//author[text() = "James Linn"]/descendant-or-self::node()'.<a id="orgb0169c1"></a>## Axis Following Examples         following::node-test[predicate]*            To visualize, see https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041         A following  axis contains      1. Following siblings of the context node     2. Descendants of following siblings     3. Following siblings of ancestor nodes       4. Descendants of following siblings of ancestor nodes         A following axis never contains         1. Ancestors of the context node     2. Descendants of the context node     3. Attribute nodes     4. Namespace nodes             For these examples, we use a simpler XMLDocument         |tree doc|     tree := '<?xml version="1.0" encoding="UTF-8"?>         <bookstore>         <book category="COOKING">       <title lang="en">Everyday Italian</title>       <author>Giada De Laurentiis</author>       <year>2005</year>       <price>30.00</price>     </book>         <book category="CHILDREN">       <title lang="en">Harry Potter</title>       <author>J K. Rowling</author>       <year>2005</year>       <price>29.99</price>     </book>         <book category="WEB">       <title lang="en">XQuery Kick Start</title>       <author>James McGovern</author>       <author>Per Bothner</author>       <author>Kurt Cagle</author>       <author>James Linn</author>       <author>Vaidyanathan Nagarajan</author>       <year>2003</year>       <price>49.99</price>     </book>         <book category="WEB">       <title lang="en">Learning XML</title>       <author>Erik T. Ray</author>       <year>2003</year>       <price>39.95</price>     </book>         </bookstore>'.         doc := (XMLDOMParser on: tree) parseDocument.     doc explore.         self xpath:'following::node()'.     self xpath:'/following::node()'.     self xpath:'/child::node()/book/following::node()[not(self::text())]'.     self xpath:'//author[text() = "James McGovern"]'.     self xpath:'//author[text() = "James McGovern"]/following::node()'.     self xpath:'//author[text() = "James Linn"]/following::node()'.<a id="org6a5f12c"></a>## Axis Following Sibling Examples         following-sibling::node-test[predicate]*            To visualize, see https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041         A following-sibling  axis contains      1. All siblings of the context node to the right of the context node (looking at the tree)     2. Empty if context node is an attribute node     3. Empty if a context node is a namespace node               For this, we use a simpler XMLDocument         |tree doc|     tree := '<?xml version="1.0" encoding="UTF-8"?>         <bookstore>         <book category="COOKING">       <title lang="en">Everyday Italian</title>       <author>Giada De Laurentiis</author>       <year>2005</year>       <price>30.00</price>     </book>         <book category="CHILDREN">       <title lang="en">Harry Potter</title>       <author>J K. Rowling</author>       <year>2005</year>       <price>29.99</price>     </book>         <book category="WEB">       <title lang="en">XQuery Kick Start</title>       <author>James McGovern</author>       <author>Per Bothner</author>       <author>Kurt Cagle</author>       <author>James Linn</author>       <author>Vaidyanathan Nagarajan</author>       <year>2003</year>       <price>49.99</price>     </book>         <book category="WEB">       <title lang="en">Learning XML</title>       <author>Erik T. Ray</author>       <year>2003</year>       <price>39.95</price>     </book>         </bookstore>'.         doc := (XMLDOMParser on: tree) parseDocument.     doc explore.             self xpath:'following-sibling::node()'.     self xpath:'/following-sibling::node()'.     self xpath:'/following-sibling::*'.        self xpath:'/child::node()/book/following-sibling::node()[not(self::text())]'.     self xpath:'//author[text() = "James McGovern"]'.     self xpath:'//author[text() = "James McGovern"]/following-sibling::node()'.     self xpath:'//author[text() = "James Linn"]/following-sibling::node()'.<a id="orga6a0f1e"></a>## Axis Namespace Examples     namespace::node-test[predicate]*        The principle nodeType for the Namespace axis is namespace        To visualize, see https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041        The namespace axis contains    1. The namespace nodes that are in scope for the context node    2. Namespace declaration attributes fo the Context node    3. Namespace declaration attributes for Ancestors of the Context node             (((XMLDOMParser onURL: 'https://w1.weather.gov/xml/current_obs/index.xml' upToLimit:nil)    	 preservesCDataNodes: true;     	 preservesCommentNodes: true) parseDocument) explore         "be sure to add the additional elements from the "Addding Complexity" section             self xpath:'//namespace::*'.        self xpath:'//namespace::*[name()="xml"]'.   "lots"     self xpath:'//namespace::*[name()!="xml"]'.     self xpath:'//namespace::*[name() = "s"]'.     self xpath:'namespace-uri(/child::node()/child::s:wx_station_index)'.     self xpath:'/child::node()/child::s:wx_station_index/namespace::*'.      self xpath:'/child::node()/child::s:wx_station_index/namespace::*[name()]'.      self xpath:'/child::node()/child::s:wx_station_index[namespace-uri()="https://dummynamespace.org/s/"]'. <a id="org1ec30ef"></a>## Axis Parent Examples    parent::node-test[predicate]*        '..' is shorthand for 'parent::node()'.        To visualize, see https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041        the parent axis contains     1. The parent of the context node     2. Is empty if there is no parent node.    3. A parent is the immediate ancestor of the context node            For these examples, we use a simpler XMLDocument        |tree doc|    tree := '<?xml version="1.0" encoding="UTF-8"?>        <bookstore>        <book category="COOKING">      <title lang="en">Everyday Italian</title>      <author>Giada De Laurentiis</author>      <year>2005</year>      <price>30.00</price>    </book>        <book category="CHILDREN">      <title lang="en">Harry Potter</title>      <author>J K. Rowling</author>      <year>2005</year>      <price>29.99</price>    </book>        <book category="WEB">      <title lang="en">XQuery Kick Start</title>      <author>James McGovern</author>      <author>Per Bothner</author>      <author>Kurt Cagle</author>      <author>James Linn</author>      <author>Vaidyanathan Nagarajan</author>      <year>2003</year>      <price>49.99</price>    </book>        <book category="WEB">      <title lang="en">Learning XML</title>      <author>Erik T. Ray</author>      <year>2003</year>      <price>39.95</price>    </book>        </bookstore>'.        doc := (XMLDOMParser on: tree) parseDocument.    doc explore.        self xpath:'/parent::*'.       self xpath:'parent::node()'.    self xpath:'/child::node()/book/parent::node()[not(self::text())]'.       self xpath:'//author[text() = "James McGovern"]'.    self xpath:'//author[text() = "James McGovern"]/parent::node()'.    self xpath:'//author[text() = "James Linn"]/parent::node()'.    self xpath:'local-name(//author[text() = "James McGovern"]/parent::node())'.    self xpath:'local-name(//author/parent::node())'.<a id="org04743d4"></a>## Axis Preceding Examples    preceding::node-test[predicate]*        To visualize, see https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041        the precedings axis contains     1. Nodes that precede the context node in reverse document order    2. Descendants of preceding siblings of the context node    3. Preceding siblings of ancestor nodes    4. Descendants of preceding siblings of ancestor nodes        the precedings axis never contains     1. Ancestors of the context node       2. Descendatns of the context node     3. Attribute nodes    4. Namespace nodes        For these examples, we use a simpler XMLDocument        |tree doc|    tree := '<?xml version="1.0" encoding="UTF-8"?>        <bookstore>        <book category="COOKING">      <title lang="en">Everyday Italian</title>      <author>Giada De Laurentiis</author>      <year>2005</year>      <price>30.00</price>    </book>        <book category="CHILDREN">      <title lang="en">Harry Potter</title>      <author>J K. Rowling</author>      <year>2005</year>      <price>29.99</price>    </book>        <book category="WEB">      <title lang="en">XQuery Kick Start</title>      <author>James McGovern</author>      <author>Per Bothner</author>      <author>Kurt Cagle</author>      <author>James Linn</author>      <author>Vaidyanathan Nagarajan</author>      <year>2003</year>      <price>49.99</price>    </book>        <book category="WEB">      <title lang="en">Learning XML</title>      <author>Erik T. Ray</author>      <year>2003</year>      <price>39.95</price>    </book>        </bookstore>'.        doc := (XMLDOMParser on: tree) parseDocument.    doc explore.        self xpath:'/preceding::*'.       self xpath:'preceding::node()'.    self xpath:'/preceding::node()'.    self xpath:'/child::node()/book/preceding::node()[not(self::text())]'.   "inspect these and see that they are in reverse document order"    self xpath:'//author[text() = "James McGovern"]'.    self xpath:'//author[text() = "James McGovern"]/preceding::node()'.    self xpath:'//author[text() = "James Linn"]/preceding::node()'.<a id="org1f0671b"></a>## Axis Preceding Sibling  Examples        preceding-sibling::node-test[predicate]*        To visualize, see https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041            the preceding-sibling axis contains     1. All the preceding siblings of the context node      2. Nodes are in reverse document order    3. Is empty if context node is an attribute node    4. Is empty if context node is a namespace node    5. is empty if the context node is the first element             For this, we use a simpler XMLDocument        |tree doc|    tree := '<?xml version="1.0" encoding="UTF-8"?>        <bookstore>        <book category="COOKING">      <title lang="en">Everyday Italian</title>      <author>Giada De Laurentiis</author>      <year>2005</year>      <price>30.00</price>    </book>        <book category="CHILDREN">      <title lang="en">Harry Potter</title>      <author>J K. Rowling</author>      <year>2005</year>      <price>29.99</price>    </book>        <book category="WEB">      <title lang="en">XQuery Kick Start</title>      <author>James McGovern</author>      <author>Per Bothner</author>      <author>Kurt Cagle</author>      <author>James Linn</author>      <author>Vaidyanathan Nagarajan</author>      <year>2003</year>      <price>49.99</price>    </book>        <book category="WEB">      <title lang="en">Learning XML</title>      <author>Erik T. Ray</author>      <year>2003</year>      <price>39.95</price>    </book>        </bookstore>'.        doc := (XMLDOMParser on: tree) parseDocument.    doc explore.        self xpath:'preceding-sibling::node()'.    self xpath:'/preceding-sibling::node()'.    self xpath:'/preceding-sibling::*'.       self xpath:'/child::node()/book/preceding-sibling::node()[not(self::text())]'.    self xpath:'//author[text() = "James McGovern"]'.    self xpath:'//author[text() = "James McGovern"]/preceding-sibling::node()'.    self xpath:'//author[text() = "James Linn"]/preceding-sibling::node()'.<a id="org8ef9e53"></a>## Axis Self Examples        self::node-test[predicate]*        '.' is shorthand for  'self::node()'            the self axis contains     1. the context node            (((XMLDOMParser onURL: 'https://w1.weather.gov/xml/current_obs/index.xml' upToLimit:nil)    	preservesCDataNodes: true;     	preservesCommentNodes: true) parseDocument) explore        "be sure to add the additional elements from the "Addding Complexity" section                    self xpath:'/child::node()/child::credit'.    self xpath:'/child::node()/child::credit/self::credit'.    self xpath:'/child::node()/child::credit_URL/self::credit_URL'.                   "looks useless,but it is logical"    self xpath:'/child::node()/child::node()[self::credit_URL  or self::credit]'.    self xpath:'/child::node()/child::node()[self::credit_URL  or self::credit][position() = last()]'.    self xpath:'/child::node()/child::node()[self::credit_URL  and self::credit]'.   "empty"        self xpath:'/self::*'.    self xpath:'//self::*'.    self xpath:'//*[self::s:substation][@location="west"][child::s:sub_station_id = "ABC5"]'                self xpath: '//s:sub_station_id [.="XYZ1"]'.         self xpath: '//s:sub_station_id [self::node()="XYZ1"]'.    (self xpath:'/.') = (self xpath:'/self::node()').<a id="orgee8aaf3"></a>## Location Path Examples            18. child::*[self::chapter or self::appendix]        19. child::*[self::chapter or self::appendix][position()=last()]        21. child::para[position()=last()]        23. child::para[position()>1]        - selects all the para children of the context node other than the first para child of the context node<a id="org6cdabbc"></a>## Wildcards in Queries            (XMLDOMParser parseURL: 'https://w1.weather.gov/xml/current_obs/index.xml')  explore.        (self xpath: '//*') size.    self xpath: '//@*' .  "selects all the attributes of any node"    self xpath: '//dude[@*]'.    self xpath: '/*'.    self xpath: 'wx_station_index/*/station_id'.                self / 'wx_station_index' / 'image' / '*'.    self xpath:  '/wx_station_index/image/*'.        self / 'wx_station_index' /  '*' / 'station_id'.    self xpath:  '/wx_station_index/*/station_id'.        "return grandchild elements of current context"    self xpath: '/*/*'.    self xpath: '/wx_station_index/*/*'.    self xpath: '/wx_station_index/*/*/*'.        "out of my depth here, or late in the day, pick one"    self / 'wx_station_index' / '*' / '*'.    self / 'wx_station_index' / '*' / '*' / '*'.    self / '*' / '*' / '*'.    self / '*' / '*' / ('*' ?? 1).    self / 'wx_station_index' / '*' / ('*' ?? 1).    self / 'wx_station_index' / '*' / '*' / ('*' ?? 1).<a id="org159eddc"></a>## Selecting Union Operator        (XMLDOMParser parseURL: 'https://w1.weather.gov/xml/current_obs/index.xml')  explore.        self xpath: '//station/station_id  |  //station/latitude'.    self xpath: '//station/latitude  |  //station/ongitude'.   "neat query to get map data of stations"<a id="org293892b"></a>## Operator Precedencethis is for XPath 1.0Highest to lowest    Grouping                       ( )     Filter                         [ ]     Unary minus                    -      Multiplication                 *, div, mod     Addition                       +, -     Relational (Comparison)        = != < <= > >=     Union                          |     Negation                       not     Conjunction                    and     Disjunction                    or <a id="orgecf8a0f"></a>## NodeSet Functions        NodeSet functions are for working with node-sets, either the implicit current node set or one passed as a parameter.        The following examples are taken from:    https://docs.oracle.com/cd/E68885_01/doc.731/e68892/dev_xpath_functions.htm#OSMDR76    https://developer.mozilla.org/en-US/docs/Web/XPath/Functions        The Format of a function description is:        - Return Value And Syntax where  foo([bar]) denotes optional argument 'bar'       - Returns:       - Example      - Example      - "notes if needed"             (XMLDOMParser parseURL: 'https://w1.weather.gov/xml/current_obs/index.xml')  explore.         self addElementNamed: 'dude' attributes: {'lang'->'en'}.     self addElementNamed: 'dude' attributes: {'version'->'1.9'}.     self addElementNamed: 'dude' attributes: {'id'->'123'}.                - evaluate(String)  "NOT IMPLEMENTED"      - Returns: NodeSet        - the node set resulting from the Xpath expression defined by the provided argument.      - Allows XPath expressions to be dynamically created.      - The argument is converted to a string as if by a call to the string function.                    - id(object)      - Returns:  NodeSet        - of the elements with the id specified (not working here)        - (the mozilla docs state that the DTD determines what an ID is. No DTD here that I am awere of.)      - self xpath:'/dude'.      - self xpath:'id("123")/dude'.      - self xpath:'id("123")//dude'.          - "the first xpath verifies the elements exist. the second two are an attempt at the function            - last()      - Returns: Number        - "An integer equal to the context size from the expression evaluation context."      - self xpath:'/wx_station_index/station[last()]'.            - local-name([node-set])      - Returns String        - the non-namespace portion of the node name of either a node set passed as a parameter or        - the current node in the current node set.      - self xpath:'local-name(/wx_station_index/station)'.      - self xpath:'/wx_station_index/*[local-name="station_id"]'.      - self xpath:'local-name(/wx_station_index/station/station_id)'.      - "these last two do not appear to work."        - name([NodeSet])      - Returns: QName        - the complete textual node name of either a node set passed as a parameter or        - the current node in the current node set.      - self xpath:'name(/wx_station_index)'.      - self xpath: 'wx_station_index[name="wx_station_index"]'.      - self xpath: '/wx_station_index[name="wx_station_index"]'.      - self xpath: '//wx_station_index[name="wx_station_index"]'.      - self xpath: '//credit[name="credit"]'.      - "the second form is not working for me"      - *"The QName is a String of the node's qualified name, including its namespace prefix and its local name."            - namespace-uri([NodeSet])      - Returns:String          - the namespace URI of the node name of either a node set passed as a parameter or        - the current node in the current node set.      - self xpath:'namespace-uri(/wx_station_index)'      - self xpath: '/wx_station_index[namespace-uri()="http://werken.com/werken-journal/"]'      - "I need some better document examples to test this stuff"        - match(NodeSet , String)  "NOT IMPLEMENTED"      - Returns NodeSet      - self xpath:'match(/*, "blur[f]+le[0-9]")'      - Throws undeclared function exception        - position()      - Returns: Number        - "Numeric index of the current item in the current node set.  (broken?)"      - self xpath:'/wx_station_index/station[position()]'.      - self xpath:'/wx_station_index/station[position() < 3]'.      - (self xpath:'/wx_station_index/station[position()]') size.<a id="org5853d8f"></a>## String Functions         (XMLDOMParser parseURL: 'https://w1.weather.gov/xml/current_obs/index.xml')  explore.            - concat(String, String [,String*])      - Returns: String         - the concatenated string      - self xpath:'concat("foo" , "bar")'.      - self xpath:'concat("foo" , "bar" ,"baz")'.      - self xpath:'concat("foo" , "bar" ,"baz", "biz" ,"bat" , "zat" , "zounds!")'.            - contains(haystack, needle)      - Returns: Boolean        - true if haystack contains needle, else false      - self xpath:'contains("fazfoozrb", "foo")'.      - self xpath:'contains(local-name(/wx_station_index/station/station_id), "sation")'.        - ends-with(haystack, needle)      - Returns: Boolean        - true if haystack ends with needle, else false      - self xpath:'ends-with("foobar", "foo")'.      - self xpath:'ends-with("foobar", "bar")'.            - lower-case([string])      - not implemented            - normalize-space([String]      - Returns: String        - The string argument or context node with all space normalized, trimming white space from the ends and compressing consecutive white space elements to a single space.      - self xpath:'normalize-space("    this   is   a   string     ")'.      - self xpath:'normalize-space(wx_station_index/credit/text())'.            - starts-with(haystack, needle)      - Returns: Boolean        - true if haystack starts with needle, else false      - self xpath:'starts-with("foobar", "foo")'.      - self xpath:'starts-with("foobar", "bar")'.        - string([Object])        - Arguments:        - Default Argument is the ContextNode      - Returns:        - String        - If the object is a node-set, the string value of the first node in the set is returned.      - A number is converted as follows:        - NaN is converted to the string NaN.        - Positive zero is converted to the string 0.        - Negative zero is converted to the string 0.        - Positive infinity is converted to the string Infinity.        - Negative infinity is converted to the string -Infinity.        - Decimal numbers between -1 and 1 are converted to a string with a single leading 0 before the decimal point.        - Boolean true is converted to the string true.        - Boolean false is converted to the string false.      - self xpath:'string(/wx_station_index/image/title)'.      - self xpath:'string(/wx_station_index/station)'.      - self xpath:'string(NaN)'.      - self xpath:'string(0)'.      - self xpath:'string(-0)'.      - self xpath:'string(Infinity)'. "differs from mozilla spec"      - self xpath:'string(-Infinity )'.      - self xpath:'string(-0.007)'.      - self xpath:'string(0.008)'.      - self xpath:'string(True)'.  "differs from mozilla spec"      - self xpath:'string(False)'. "differs from mozilla spec"            - string-length([String])      - Returns:        - an integer equeal to the number of characters in the string or,        - the current context node coerced to a string.      - self xpath:'string-length("aa-bb" )'.      - self xpath:'string-length(/wx_station_index/station[last()])'.                - substring-after(haystack, needle)      - Returns:        - a String      - self xpath:'substring-after("aa-bb" , "-")'.      - self xpath:'substring-after("aa-bb" , "a")'.      - self xpath:'substring-after("aa-bb" , "b")'.      - self xpath:'substring-after(local-name(/wx_station_index/station/station_id), "stat")'.            - substring-before(haystack, needle)      - Returns:        - a String      - self xpath:'substring-before("aa-bb" , "-")'.      - self xpath:'substring-before("aa-bb" , "a")'.      - self xpath:'substring-before(local-name(/wx_station_index/station/station_id), "ion")'.            - translate(targetstring , abc, XYZ)      - Arguments:        - targetstring = string to act on         - abc = string of characters that will be replaced.        - XYZ the string of characters used for replacement. The first Character in XYZ will replace every occurence of the first character in abc that appears in targetstring      - Returns:        - the translated string      - self xpath:'translate("hello world" , "abcdefghijklmnopqrstuvwxyz" , "ABCDEFGHIJKLMNOPQRSTUVWXYZ")        - upper-case([string])      - not implemented<a id="orgef96934"></a>## Boolean Functions         (XMLDOMParser parseURL: 'https://w1.weather.gov/xml/current_obs/index.xml')  explore.        - boolean(expression)      - Returns: true or false      - Arguments: (source; https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/boolean)        - A number evaluates to false if it is positive or negative zero or NaN. Otherwise, it evaluates true.        - A node-set evaluates to true if it is non-empty.        - A string evaluates to false if it an empty string. Otherwise, it evaluates to true.        - An object of a type other than the four basic types is converted to a boolean in a way that is dependent on that type.      - self xpath:'boolean(0)'.      - self xpath:'boolean(-0)'.      - self xpath:'boolean(NaN)'.      - self xpath:'boolean(999)'.      - self xpath:'boolean(-999)'.      - self xpath:'boolean(/wx_station_index/station)'.      - self xpath:'boolean("")'.      - self xpath:'boolean("dude")'.      - self xpath:'boolean("An object of a type other than the four basic types is converted to a boolean in a way that is dependent on that type.")'.      - self xpath:'boolean("I need some good examples of the above expression! .")'.        - not(boolean)      - Returns: the negaged boolean      - self xpath:'not(boolean(0))'.      - self xpath:'not(boolean(-0))'.      - self xpath:'not(boolean(NaN))'.      - self xpath:'not(boolean(999))'.      - self xpath:'not(boolean(-999))'.      - self xpath:'not(boolean(/wx_station_index/station))'.      - self xpath:'not(boolean(""))'.      - self xpath:'not(boolean("dude"))'.      - self xpath:'not(boolean("An object of a type other than the four basic types is converted to a boolean in a way that is dependent on that type."))'.        - false()      - Returns: Boolean false      - self xpath:'false()'.        - true()      - Returns: Boolean true      - self xpath:'true()'.<a id="org27b363c"></a>## Number Functions         (XMLDOMParser parseURL: 'https://w1.weather.gov/xml/current_obs/index.xml')  explore.            - ceiling(number)      - Arguments:        - a number      - Returns:        - Returns the smallest integer that is not less than the number argument.      - self xpath:'ceiling(99.9)'.      - self xpath:'ceiling(-113.21667)'.      - self xpath: '/wx_station_index/station[ceiling(longitude)=-114]'.            - count(NodeSet)      - Arguments:        - a NodeSet to be counted      - Returns:        - Integer representing the number of nodes in the node-set      - self xpath:'count(/)'.      - self xpath:'count(//station)'.      - self xpath:'count(//image)'.            - number([object])      - Arguments: (optional)        - Object to be converted to a number        - if ommitted, the current context node      - Returns:         - resulting number after converting the object        - Strings are converted to a number by stripping the leading whitespace in the string before the number and ignoring whitespace after the number. If the string does not match this pattern, then the string is converted to NaN.        - Boolean true is converted to 1. False is converted to 0.        - A node-set is first converted to a string as if by a call to the string() function and then converted in the same way as a string argument.        - An object of a type other than the four basic types is converted to a number in a way that is dependent on that type.      - self xpath:'number("1")'.      - self xpath:'number("    1    ")'.      - self xpath:'number(true())'.      - self xpath:'number(false())'.      - self xpath:'number(//@version)'.      - self xpath:'number("An object of a type other than the four basic types is converted to a number in a way that is dependent on that type.")'.            - floor(number)      - Arguments:        - a number      - Returns:        - Returns the largest integer that is not greater than the number argument.      - self xpath:'floor(99.9)'.      - self xpath:'floor(-113.21667)'.      - self xpath: '/wx_station_index/station[floor(longitude)=-114]'.            - round(number)      - Arguments:        - a number      - Returns:        - Rounds the number argument.      - self xpath:'round(99.9)'.      - self xpath:'round(-113.21667)'.      - self xpath: '/wx_station_index/station[round(longitude)=-114]'.            - sum(NodeSet)      - Arguments:        - The node to be evaluated        - Each node in this node-set is evaluated as if it were passed to the number() function, and a sum of the resulting numbers is returned.      - Returns:        - Number      - self xpath: '/wx_station_index/station[number(longitude)=-113.21667]'.      - self xpath:'number(/wx_station_index/suggested_pickup_period)'<a id="orgda584ff"></a>## Definitions  [XPathDefinitionsHelp]    pulled from https://www.stylusstudio.com/docs/v2009R2/d_xpath33.html<a id="org04a9f6f"></a>### Context NodeA context node is the node the XPath processor is currently looking at. The context node changes as the XPath processor evaluates a query. If you pass a document to the XPath processor, the root node is the initial context node. If you pass a node to the XPath processor, the node that you pass is the initial context node. During evaluation of a query, the initial context node is also the current node.<a id="orgaceea31"></a>### Context Node SetA context node set is a set of nodes that the XPath processor evaluates.<a id="org915faef"></a>### Current NodeCurrent node is the node that the XPath processor is looking at when it begins evaluation of a query. In other words, the current node is the first context node that the XPath processor uses when it starts to execute the query. During evaluation of a query, the current node does not change. If you pass a document to the XPath processor, the root node is the current node. If you pass a node to the XPath processor, that node is the current node.<a id="orgccdf420"></a>### Document ElementThe document element is the element in a document that contains all other elements. The document element is an immediate child of the root node. When you obtain the document element of a document, you obtain all marked-up text in that document.IMPORTANT NOTE: These terms get a bit wonky when exploring a live XMLDocument in smalltalk.<a id="org4e5908f"></a>### FilterA filter in a query specifies a restriction on the set of nodes to be returned. For example, the filter in the following query restricts the result set to book elements that contain at least one excerpt element    book[excerpt]  <a id="orge8915d6"></a>### Location Path ExpressionA location path expression is an XPath expression. It has the following format:    [/]LocationStep[/LocationStep]...<a id="orgc091451"></a>### Location StepAn XPath expression consists of one or more location steps. A location step has the following format:    [axis::]node_test[[filter] [filter]...] <a id="org8468530"></a>### Node TestYou apply a node test to a list of nodes. A node test returns nodes of a particular type or nodes with a particular name. For example, a node test might return all comment nodes, or all book elements.<a id="org9cfa680"></a>### Root NodeTheroot node is the root of the tree. It does not occur anywhere else in the tree. The document element node for a document is a child of the root node. The root node also has as children processing instructions and comment nodes representing processing instructions and comments that occur in the prolog and after the end of the document element.NOTE: This is not to be confused with the XMLDocument root.<a id="org1c66270"></a>### Nodes             In XPath, there are seven kinds of nodes         1. element         2. attribute         3. text         4. namespace         5. processing-instruction         6. comment         7. document             the <?xml version="1.0" encoding="UTF-8"?> is not a node and is not visible to XPath.            XML documents are treated as trees of nodes. The topmost element of the tree is called the root element.                Important point from stackoverflow:        https://stackoverflow.com/questions/132564/whats-the-difference-between-an-element-and-a-node-in-xml        The Node object is the primary data type for the entire DOM.            A node can be an element node, an attribute node, a text node, or any other of the node types explained in the "Node types" chapter.                Nodes include            1. the root element node.  <words>       2. element nodes    <word lange="it">Pronto</word>       3. attribute nodes  lang="it"<a id="org67eed79"></a>### NodeSetsNode sets are Sets of nodesAll node sets produced by XPath location path expressions are sorted by the order they appear in the document<a id="org547b3f6"></a>### Atomic Values [atomics]Atomic values are 1.  strings    1.  Hello World    2.  "it"2.  numbers    1.  -99    2.  3.143.  booleans    1.  true    2.  false<a id="org3464df8"></a>### Basic Tree Relationships [relatives]To visualize, see <https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041>1.  Parent    1.  each node can have at most one parent.    2.  the root node has node parent    3.  In XPath, attribute and namespace nodes treat the element they belong to as their parent2.  Children    1.  Document and element nodes may have zero, or more children.    2.  children can be        1.  elements        2.  text nodes        3.  comments        4.  processing instructions    3.  Technically, attribute and namespace nodes are not children of their parents but are treated as such in XPath3.  Siblings    1.  are child nodes that have the same parent.    2.  attributes do not have siblings    3.  namespace nodes do not have siblings4.  Ancestors are    1.  A nodes parent    2.  parent's parent    3.  parent's parent's parent etc&#x2026;5.  Descendants are    1.  A nodes children    2.  children's children&#x2026;etc..<a id="org930133e"></a>### Expr    see https://www.w3.org/TR/1999/REC-xpath-19991116/#NT-Expr<a id="org37e40ee"></a>### NCName     From https://stackoverflow.com/questions/1631396/what-is-an-xsncname-type-and-when-should-it-be-used         NCName stands for "non-colonized name".      NCName can be defined as an XML Schema regular expression [\i-[:]][\c-[:]]*         ...and what does that regex mean?      \i and \c are multi-character escapes defined in XML Schema definition at http://www.w3.org/TR/xmlschema-2/#dt-ccesN         \i is the escape for the set of initial XML name characters and \c is the set of XML name characters.         [\i-[:]] means a set that consist of the set \i excluding a set that consist of the colon character :.         So in plain English it would mean "any initial character, but not :".         The whole regular expression reads as "One initial XML name character, but not a colon, followed by zero or more XML name characters, but not a colon."        The practical restrictions of NCName are that it cannot contain several symbol characters like :, @, $, %, &, /, +, ,, ;, whitespace characters or different parenthesis.    Furthermore an NCName cannot begin with a number, dot or minus character although they can appear later in an NCName.<a id="org924c9ff"></a>### QName    QName	           ::=   PrefixedName | UnprefixedName    PrefixedName	   ::=   Prefix ':' LocalPart    UnprefixedName     ::=   LocalPart    Prefix	           ::=   NCName    LocalPart          ::=   NCName<a id="org805bc5a"></a>### Predicate    Predicate	   ::=   [' PredicateExpr ']'	    PredicateExpr	   ::=   Expr	<a id="orgad92c00"></a>## BibliographySources used in developing this Help include    https://www.w3.org/TR/1999/REC-xpath-19991116/     https://www.w3.org/TR/1999/REC-xpath-19991116/#section-Conformance        http://books.pharo.org/booklet-Scraping/pdf/2020-02-04-scrapingbook.pdf        https://www.w3schools.com/xml/xpath_intro.asp    https://www.w3schools.com/xml/xpath_nodes.asp    https://www.w3schools.com/xml/xpath_syntax.asp    https://www.w3schools.com/xml/xpath_axes.asp    https://www.w3schools.com/xml/xpath_operators.asp    https://www.w3schools.com/xml/xpath_examples.asp            https://stackoverflow.com/questions/132564/whats-the-difference-between-an-element-and-a-node-in-xml        https://www.stylusstudio.com/docs/v2009R2/d_xpath4.html#wp205792    https://www.stylusstudio.com/docs/v2009R2/d_xpath33.html        https://docs.oracle.com/cd/E68885_01/doc.731/e68892/dev_xpath_functions.htm#OSMDR767        https://developer.mozilla.org/en-US/docs/Web/XPath/Functions        https://www.researchgate.net/figure/XPath-Axes-Partition-from-Context-Node_fig3_29646041